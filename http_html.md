# HTTP部分

## 什么是HTTP协议：

- HTTP是基于TCP/IP的可靠的超文本传输协议。

- 用于在客户端和服务器之间传输文字，图片，音频，视频等超文本数据。
- HTTP协议是单向的基于请求-应答模式的协议。
- HTTP协议是无状态的。



## 怎么理解HTTP协议的无状态性：

这种无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。

解决这种无状态的方法：1.cookie  2.session



## HTTP与HTTPS:

HTTP的缺点：

- **传输的数据是无加密的**，内容可能会被窃取
- 没有身份认证，用户身份可能会被伪装
- 无法验证报文的完整性，数据可能会被篡改

HTTPS协议：HTTP结合SSL安全协议实现**加密传输**和身份认证。

HTTP的端口为80，HTTPS的端口为443.



https://www.jianshu.com/p/14cd2c9d2cd2

前言：

- 对称加密：对 明文的加密 和 对密文的解密 都是使用**私钥**来完成的。也称为私钥加密。

  - 加密过程：**明文 + 加密算法 + 私钥 => 密文**

  - 解密过程：**密文 + 解密算法 + 私钥 => 明文**

  - 缺点：由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解。所以密钥安全管理很困难。

- 非对称加密：非对称加密使用一对密钥，即公钥和私钥。
  - 私钥自己保存，公钥是公共的密钥，任何人都可以获得该密钥。
  - 用公钥或私钥中的任何一个进行加密，用另一个进行解密。
  - 加密过程：**明文 + 加密算法 + 公钥 => 密文**
  - 解密过程：**密文 + 解密算法 + 私钥 => 明文**



**HTTPS协议 = HTTP协议 + SSL/TLS协议**

- SSL协议负责加密和解密，HTTP协议负责数据传输



一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。
1.客户端向服务器发起**HTTPS请求**，连接到服务器的443端口

2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。

3.服务器将自己的**公钥**发送给客户端。

4.客户端收到服务器端的证书之后，会**对证书进行检查**，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。如果公钥合格，那么客户端会生成一个随机值，**这个随机值就是用于进行对称加密的密钥**，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。

5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。

6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。

7.然后服务器将加密后的密文发送给客户端。

8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。



综合起来说就是，原本通过对称加密传输数据可能存在密钥被盗的风险，现在通过非对称加密又对传递的密钥进行了一次加密。



## HTTP1.0，HTTP1.1，HTTP2.0的区别：

HTTP1.0：

- 采用的短连接，即浏览器的每次请求都需要与服务器建立一个新的连接，服务器处理完成后立即断开连接。这样就使得网络的利用率很低，且服务器无法记住用户之前的状态。

HTTP1.1：

- 是目前互联网使用最广泛的协议
- 采用的是长连接，新增了一个Connection字段，将其设置为keep-alive就可以保证连接不断开，设置为false用来告诉服务器关闭长连接。
- 新增了Cache-Control字段，用来实现强缓存和协商缓存。



http1.1长连接的不足：

HTTP 1.1 基于串行文件传输数据，因此这些请求必须是有序的，必须等下上一个请求接受才能发起下一个请求，所以会受到前面请求的阻塞。而且一个请求只能又有一个响应。



HTTP2.0：

- 二进制分帧
  - http1.X的解析是基于文本的，http2.0将所有的传输信息分割为更小的消息和帧，并对他们采用二进制格式编码。改进了传输的性能。
- 多路复用（[概念：](https://baike.baidu.com/item/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/1180849?fr=aladdin)一个信道可以同时传输多路信号）：
  - HTTP/2 对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。
  - http2的传输是基于二进制帧的，流就是由二进制帧组成的，二进制帧的头部信息会标识自己属于哪一个流，所以这些帧是可以交错传输，然后在接收端通过帧头的信息组装成完整的数据。这样就解决了线头阻塞的问题，同时也提高了网络速度的利用率。
- 头部压缩
- 服务器推送
  - 可以实现一个请求对应多个响应。





## HTTP报文的基本结构：

由三大部分组成：起始行、头部字段、消息正文。

其中“请求行 + 头部字段”构造了**请求头**，“状态行 + 头部字段”构成**响应头**。

- 起始行
  - 请求行：简要地描述了客户端想要如何操作服务器端的资源
    - `GET / HTTP/1.1   `
    - 由三部分组成：**请求方法   请求资源路径    http协议版本号**
  - 状态行：表示服务器响应的状态
    - HTTP/1.1 200 OK
    - 由三部分组成：**http协议版本号   状态码   状态码的补充说明文字**

- 头部字段
- 消息正文



## 常见的头部字段

- 头部字段key-value的形式，可以自定义。

- 分为4类：通用字段、请求字段、响应字段、实体字段（专门描述body的额外信息）

- 通用字段

  - date: 表示报文创建时间

  ```
  date: Tue, 18 Aug 2020 04:58:26 GMT
  ```

- 请求字段

  - cookie
  - 与缓存相关的If-Modified-Since

- 响应字段

  - set-cookie
  - 与重定向相关的location

- 实体字段

  - Content-Type: 响应内容的数据类型
  - Content-Encoding:  响应内容的编码方式


## HTTP的请求方式：



### 常见的请求方式：

HTTP1.0 定义了三种请求方式：get，post，head

HTTP1.1 新增了五种请求方法：put，delete，options，trace，connect



- get请求：从服务器获取资源
- post请求：向服务端请求新增资源（例如上传文件）。数据被包含在请求体中。
- head请求：
  - 与GET类似，也是请求从服务器获取资源。但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。
  - 实际应用：检查一个文件是否存在
- put请求：向服务端请求修改某个已存在的资源
- delete请求：请求删除服务器的资源
- options请求：查看服务器支持的请求方式
- trace请求：回显服务器收到的请求，主要用于测试或诊断
- connect请求：要求服务器为客户端和另一台远程服务器建立一条特殊的连接隧道，这时 Web 服务器在中间充当了代理的角色。



### get请求和post请求的区别：

- 相同点：都需要通过建立TCP/IP连接
- 不同的：
  - 用途方面：get用于请求数据，post用于修改数据。
  - 缓存方面：受到用途的影响。get用于获取数据，可以使用缓存。post用于修改数据，不用使用缓存。
  - 传递参数的方式：get采用**明文传输**，post将请求参数放在**请求体**中。
  - 安全性方面：正是由于传递参数方式的不同，导致get请求的明文存在**安全隐患**，而post将参数存在body中是相对安全的。



### get请求传递的参数长度的误区：

HTTP协议未规定GET和POST请求参数的长度限制。

GET的最大长度限制是因为浏览器和web服务器限制了URL的长度。





## HTTP的状态码：

响应报文中的状态码描述了服务器的响应结果。

状态码总共分为5类：

- `1xx`：相关信息，表示目前是协议处理的**中间状态**，还需要后续的操作。
  - `101` : **切换协议**。
    - 服务器根据客户端的请求切换协议。只能切换到更高级的协议。
    - 例如，切换到HTTP的新版本协议，或从HTTP协议切换为WebSocket协议。
- `2xx`：操作成功，报文已经收到并被**正确**处理。
  - `200`：表示请求成功
  - `206`：范围请求，服务器返回对应请求范围的数据
- `3xx`：重定向，**资源位置**发生变动，需要客户端重新发送请求。
  - `301`：永久移动。
    - 请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替。
    - 实际应用场景：
      - 浏览器看到 301，就知道原来的 URI“过时”了，就会做适当的优化。比如**历史记录、更新书签**，下次可能就会直接用新的 URI 访问，省去了再次跳转的成本
      - 搜索引擎的爬虫看到 301，也会更新索引库，不再使用老的 URI
  - `302`： 临时移动。
    - 与301类似。但资源只是临时被移动。客户端应继续使用原有URI
    - 实际应用场景：
      - 未登陆的用户访问用户中心重定向到登录页面
      - 网站维护时将链接跳转到静态页面
  - `304`：未修改。通常是用在协商缓存中，表示请求的资源未修改，应该直接从浏览器缓存中取数据。
- `4xx`：客户端错误，**请求报文有误**，服务器无法处理。
  - `400`：请求报文有误。常见的原因是参数名有误或发送数据时未将数据转换为json字符串。
  - `401`：本次请求需要用户的身份认证
  - `403`：服务器拒绝执行本次请求
  - `404`：找不到资源
- `5xx`：**服务器错误**，服务器在处理请求时内部发生了错误。
  - `500`：服务器内部错误，无法完成请求
  - `501`：服务器不支持请求的功能，无法完成请求
  - `502`：作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应
  - `503`：由于超载或系统维护，服务器暂时无法处理客户端的请求



## 一句话概括RESTFUL：

一句话概括就是，**用URL( /zoos/ID )定位资源，用HTTP请求方法(GET)描述操作。**



- restful是一种api设计规范，用于web数据接口的设计。
- **设计准则：**
  - 客户端发出的数据操作指令应该是"动词（请求方法） + 宾语（资源）"的结构。eg: GET /zoos/ID   ;   
  - 复数url，例如students
  - 返回json格式的数据
  - 必须返回状态码



# HTML部分



## HTML中的DOCTYPE与严格模式和混杂模式的关系：

- 严格模式，也称为标准模式。这种模式下，浏览器使用W3C的标准解析渲染页面。
- 混杂模式，也称为怪异模式。这是一种比较宽松的向后（旧）兼容的模式，浏览器会使用老版本浏览器的规则来解析渲染页面，由于不同浏览器的混杂模式不一样，所以显示的效果会**大相径庭**。



- 浏览器选择使用哪种模式是由DOCTYPE来确定的。DOCTYPE用于指明浏览器在渲染时使用哪一种DTD(文档类型定义)。
  - 如果不存在DOCTYPE声明或形式不正确，则会触发怪异模式，浏览器会依据自己的规则来渲染页面，这种一般常见于旧的系统中。
  - 如果包含严格的DTD，则会以标准模式呈现。
  - 对于HTML5来说，它不是基于SMGL（标准通用标记语言）来实现的，所以没有DTD，也就没有严格模式与混杂模式的区别。所以在开头一般写为<!DOCTYPE html>



## web Quality

- 无障碍性是指能够被残障人士使用的易用的网站。

- 具体实现：

  - 设置相对的字体大小，这样用户就能够使用浏览器菜单来改变默认的字体尺寸。

  - 为图片添加alt属性，当浏览器不能正常显示图像时，仍能知道图像的相关描述。





## 对HTML语义化标签的理解：

- 简单来说，就是正确的标签做正确的事。
- 对于开发者而言，语义化标签有利于阅读，便于团队的开发和维护。
- 对于机器而言，有利于搜索引擎优化，搜索引擎的爬虫依赖于标签来确定上下文和各个关键字的权重，有效提升网站的排名。
- 其他方面，支持读屏软件，方便其他设备的解析，利于无障碍阅读，提高可访问性。



## 常见的语义化标签：

- header （网站名称，logo，存放nav）
- nav （导航栏）
- main（文档的主体部分，存放section）
- section（文档的各个章节）
- artical（独立性强的内容：文章，博客，用户评论）
- aside（导航，广告）
- footer（版权，网站信息）





## iframe:

### 什么是iframe?

iframe是一个内联框架元素 ，能够另一个html页面嵌入到当前页面中。



### iframe的缺点：

- iframe会阻塞主页面的**onload事件**；
- window的onload 事件在所有 iframe 加载完毕后(包含里面的元素)才会触发,因此会影响网页加载速度。
- **搜索引擎**无法解读iframe，不利于SEO;
- **iframe和主页面共享连接池，可能会阻塞主页面资源的加载**。（连接池：浏览器与web服务器的并发连接数量，连接池是有限的）

解决iframe阻塞主页面onload事件的方案：

```html
//动态的为iframe设置src属性
<iframe id="frame"></iframe>
<script>
    frame.src="xxx.html"
</script>
```



### iframe通信：

同源情况下：直接通信

跨域请求下：

- postMessage
- window.name
- location.hash
- document.domain





## HTML5的新特性：

- 标签方面
  - 语义化标签	header nav article section aside footer
  - 输入表单类型     color calander date time email url search
  - 多媒体标签    audio video source embed track
- 存储方面
  - 提供了web存储（localStorage,sessionStorage）
  - 还提供了本地离线存储，即把需要离线存储在本地的文件列在一个manifest配置文件
- 其他：
  - 拖拽功能 drag/drop
  - 全双工协议websocket
  - web worker线程
  - 地理定位
  - canvas绘图





























