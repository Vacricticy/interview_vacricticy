# :car:计算机基础

https://blog.csdn.net/mountain_hua/article/details/82721369?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param

## 计算机网络：

### TCP建立连接的三次握手过程：

基础准备：

- 序号(seq):
  - TCP的传输是面向字节流的。
  - TCP传输的每一个报文都带有一个序号seq字段，用于表示当前数据的第一个字节的序号。
  - 比如这一次传输的报文seq为301，携带的数据中有100个字节，则下一次传输时报文的seq字段为401。
- 确认号ack：
  - 期望收到对方下一个报文段的第一个数据字节的序号。
- 确认ACK字段
  - 当ACK=1时确认号字段才有效。
  - 当ACK=0时确认号无效。
  - 在建立连接后，所有传输的报文都应将ACK=1
- 同步SYC字段
  - 这是用来建立连接时用的同步序号。
  - 当SYC=1,ACK=0时，表示这是一个连接请求报文。
  - 对方若同意建立连接，则应在响应报文中使SYN=1,ACK=1
- 终止FIN字段
  - 用于释放一个连接
  - 当FIN字段的值为1时，表示当前报文的发送方的数据已经发送完毕，然后要求释放连接



三次握手建立连接的过程：

- 服务器进程先创建传输控制块TCB，并进入LISTEN（收听）状态，等待客户端的连接请求。

- 客户端创建传输控制块TCB，向服务器发送**连接请求报文**
  - 该报文中同步位SYN=1（表示这是一个连接请求）,然后初始序号设为seq=x 
  - 此时客户端进入了SYN-SENT（同步已发送）状态。

- 服务器接收到报文后，则**向A发送确认**
  - 该确认报文中SYN=1,ACK=1（表示这是一个确认报文），同时此时的确认号ack=x+1（即期待收到的下一个报文的序号为x+1）,同时为自己选择一个初始序号seq=y。
  - 此时TCP服务器进程进入SYN-RCVD(同步收到)状态。
- TCP客户端在收到服务端的确认后，还需要向服务端发送确认报文，（表示自己已经收到确认）
  - 此时确认报文中ACK=1，确认号ack=y+1（表示下一次期望收到的服务器的报文序号为y+1）然后自己的序号=x+1
  - 此时TCP客户端进入ESTABLISHED状态



客户端最后还要发送一次确认的原因：

是为了验证自己所收到的确认报文是否有效，因为存在这样一种情况：就是服务端接受到的是一个失效的请求报文，而服务端又根据这个报文返回了一个确认报文，所以此时建立连接的话是无效的。因为客户端已经不需要这次连接了，如果硬要连接的话，会占用服务端的资源。



四次挥手建立连接的过程：

- 客户端发送**连接释放报文**
  - 该报文中，终止控制位FIN为1（表示该报文是一个连接释放报文），seq=u
  - 此时客户端进入FIN-WAIT-1(终止等待1)状态，等待服务端的确认。
- 服务端接受到后，发送**确认报文**
  - 该确认报文中，ACK=1(表示该报文为一个确认报文)，然后确认号ack=u+1（表示期望收到的下一个报文序号为u+1）,自己的序号为v。
  - 此时服务端进入CLOSE-WAIT（关闭等待状态）
  - 此时客户端进入FIN-WAIT2(终止等待2)的状态，等待服务端发来的释放报文。

- 服务器所处的关闭等待状态是一个半关闭的状态，即此时客户端没有数据发送给服务端，但服务端可以继续发送数据。
- 服务端的数据发送完毕后，会向客户端发送**连接释放报文**。
  - 该报文中FIN=1（表示该报文是一个连接释放报文），确认号等于上一次客户端发送的连接释放的报文的序号+1。
  - 此时服务端进入LAST-ACK(最后确认)的状态，等待客户端的确认。
- 客户端在收到服务端的连接释放报文后，立即发出**确认报文**
  - 该确认报文的ACK=1,(表示这是一个确认报文)，然后序号等于之前连接释放报文的序号+1
  - 然后客户端进入TIME-WAIT(时间等待)状态
- 经过时间等待计时器设置的时间2MSL后，A进入到CLOSED状态。
- 然后A会撤销相应的传输控制块TCB,此时TCP连接就正式结束了。



客户端设置2MSL的目的：

- 为了保证A发送的最后一个ACK报文能够到达B。

- 为了能在这个时间段接受到B重传的FIN+ACK报文段，什么时候B会重传这个连接释放报文段？当B发送这个报文后，迟迟没有接受到A发送的确认报文后，B便会重传。
- 在这个2MSL中，如果A接受到了B的重传，就会重新发送一个确认报文，而此时2MSL也会重新计时。



- 防止“已失效的连接请求报文”出现在本连接中。





第一次握手：起初两端都处于CLOSED关闭状态，Client将标志位SYN置为1，随机产生一个值seq=x，并将该数据包发送给Server，Client进入SYN-SENT状态，等待Server确认；

第二次握手：Server收到数据包后由标志位SYN=1得知Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=x+1，随机产生一个值seq=y，并将该数据包发送给Client以确认连接请求，Server进入SYN-RCVD状态，此时操作系统为该TCP连接分配TCP缓存和变量；

第三次握手：Client收到确认后，检查ack是否为x+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=y+1，并且此时操作系统为该TCP连接分配TCP缓存和变量，并将该数据包发送给Server，Server检查ack是否为y+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client和Server就可以开始传输数据。



### TCP和UDP的区别，为什么三次握手四次挥手

相同点：都是传输层的协议

不同点：TCP（传输控制协议）是面向连接的，面向字节流的，可靠的传输层协议。

UDP（用户数据报协议）是无连接，不可靠，面向数据报的，尽最大努力交付的协议。



为什么TCP要进行四次挥手呢？

因为是双方彼此都建立了连接，因此双方都要释放自己的连接，A向B发出一个释放连接请求，他要释放链接表明不再向B发送数据了，此时B收到了A发送的释放链接请求之后，给A发送一个确认，A不能再向B发送数据了，它处于FIN-WAIT-2的状态，但是此时B还可以向A进行数据的传送。此时B向A 发送一个断开连接的请求，A收到之后给B发送一个确认。此时B关闭连接。A也关闭连接。



为什么要有TIME-WAIT这个状态呢，这是因为有可能最后一次确认丢失，如果B此时继续向A发送一个我要断开连接的请求等待A发送确认，但此时A已经关闭连接了，那么B永远也关不掉了，所以我们要有TIME-WAIT这个状态。

当然TCP也并不是100%可靠的。





### cdn原理

CDN的全称是Content Delivery Network，即内容分发网络。CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应数据。



### :white_check_mark: OSI七层模型：

osi七层模型可以说是面试必考基础了

从上到下分别是：

应用层：用户的应用程序和网络之间的接口。文件传输，常用协议HTTP，snmp,FTP ,

表示层：协商数据交换格式，代码转换，数据加密，

会话层：建立，解除会话

传输层：提供端对端的接口，tcp,udp

网络层：为数据包选择路由，IP，icmp

数据链路层：将数据分帧

物理层：将数据转换为可通过物理介质传送的电子信号





### TCP/IP的网络模型：

TCP/IP模型是一系列网络协议的总称，这些协议的目的是使得计算机之间可以进行信息交换，

TCP/IP模型四层架构从下到上分别是链路层，网络层，传输层，应用层

链路层的作用是负责建立电路连接，是整个网络的物理基础，典型的协议包括以太网，ADSL等，

网络层负责分配地址和传送二进制数据，主要协议是IP协议，

传输层负责传送文本数据，主要协议是TCP

应用层负责传送各种最终形态的数据，是直接与用户信息打交道的层，主要协议是http，ftp等





## 操作系统：

内存管理，分页
页面置换算法 LRU UPT
进程调度算法
进程-资源-死锁









### 什么是进程和线程,进程和线程的区别

进程：是操作系统**资源分配的**基本单位。（所谓的资源就是计算机里的中央处理器，内存，文件，网络等等）

线程，是进程的一部分，是**任务调度和执行**的基本单位。





### 线程的哪些资源共享，哪些资源不共享

共享的资源有

a. 堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）

b. 全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的

c. 静态变量虽然对于局部变量来说，它在代码中是“放”在某一函数中的，但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的

d. 文件等公用资源  这个是共享的，使用这些公共资源的线程必须同步。Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。

独享的资源有

a. 栈 栈是独享的

b. 寄存器  这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值难道不一样吗？其实线程里存放的是副本，包括程序计数器PC

### 进程间的通信方式有哪些

总共有八种，面试中只要能大概答上三四种方式的原理就可以了

1、无名管道：半双工的通信方式，数据只能单向流动且只能在具有亲缘关系的进程间使用

2、高级管道：将另一个程序当作一个新的进程在当前程序进程中启动，则这个进程算是当前程序的子进程，

3、有名管道，：也是半双工的通信方式，但是允许没有亲缘进程之间的通信

4、消息队列：消息队列是有消息的链表，存放在内核中，并由消息队列标识符标识，消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限的缺点

5、信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问，它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源，

6、信号：用于通知接受进程某个事件已经发生

7、共享内存：共享内存就是映射一段能被其他进程所访问的内存。这段共享内存由一个进程创建，但是多个进程可以访问，共享内存是最快的IPC 方式，往往与其他通信机制配合使用

8、套接字：可用于不同机器之间的进程通信

### linux指令用的多吗，怎么进行进程间通信



### kill指令了解过吗



###  Linux查询进程指令，查询端口，杀进程

查询进程：

ps 命令用于查看当前正在运行的进程。

grep 是搜索

例如： ps -ef | grep java

表示查看所有进程里CMD是java的进程信息

ps -aux | grep java

-aux 显示所有状态

ps

杀死进程：

kill -9[PID]



## 数据库

### Redis和 mysql的区别

（1）类型上

从类型上来说，mysql是关系型数据库，redis是缓存数据库

（2）作用上

mysql用于持久化的存储数据到硬盘，功能强大，但是速度较慢

redis用于存储使用较为频繁的数据到缓存中，读取速度快

（3）需求上

mysql和redis因为需求的不同，一般都是配合使用。

